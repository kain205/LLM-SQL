# Knowledge Base for the `violations` Table

## Part 1: Overview and Business Logic

### Overview
The `violations` table is designed to record and manage all workplace rule violations. Each record corresponds to a specific violation by an employee, including information about the violator, the type of violation, time, location, and resolution status.

### Business Logic
- **Total violations:** To count the total number of violations, use `COUNT(id)`.
- **Unresolved violations:** A violation is considered "unresolved," "in progress," or "pending" when the `status` column has the value `'In Progress'`.
- **Resolved violations:** A violation is considered "resolved" or "completed" when the `status` column has the value `'Resolved'`.
- **Violations by date/week/month:** Time-based queries (today, yesterday, this week, etc.) should be handled using PostgreSQL's date functions on the `violation_time` column.

---

## Part 2: Detailed Column Explanations

### Column: `id`
- **Meaning:** A unique identifier for each violation. This is the primary key of the table.
- **Sample values:** `1`, `2`, `3`, ...

### Column: `employee_name`
- **Meaning:** Stores the full name of the employee who committed the violation.
- **Sample values:** `'Nguyen Van A'`, `'Tran Thi B'`, `'Le Van C'`.

### Column: `department`
- **Meaning:** The department or unit where the employee works.
- **Sample values:** `'Production'`, `'Logistics'`, `'Maintenance'`, `'Security'`, `'Office'`.

### Column: `violation_type`
- **Meaning:** A specific description of the violation.
- **Sample values:** `'Arriving late'`, `'Not wearing uniform'`, `'Not wearing a helmet'`.
- **Synonym Analysis (Important):**
    - **Arriving late:** `'Arriving late'` and `'Coming to work late'` have the same meaning.
    - **Missing safety gear (helmet):** `'Not wearing helmet'`, `'Not using safety helmet'`, and `'Missing helmet at construction site'` all refer to the same offense of not wearing a safety helmet.
    - **Improper parking:** `'Improper parking'` and `'Parking in a restricted area'` have the same meaning.
    - **Incorrect uniform:** `'Not wearing uniform'` and `'Wearing incorrect uniform'` can be considered equivalent.

### Column: `area`
- **Meaning:** The specific location or area where the violation occurred.
- **Sample values:** `'Workshop A'`, `'Gate 2'`, `'Parking Lot'`, `'Cafeteria'`.

### Column: `violation_time`
- **Meaning:** The exact timestamp when the violation occurred.
- **Sample values:** `2025-09-21 10:00:00`, `2025-09-22 08:15:00`.

### Column: `status`
- **Meaning:** The processing status of the violation incident.
- **Sample values:** `'Resolved'`, `'In Progress'`.

---

## Part 3: Advanced Q&A-SQL Examples

### Example: Time-based Conditional Queries
- **User question:** "How many employees committed a violation yesterday?"
- **SQL command:**
  ```sql
  SELECT COUNT(DISTINCT employee_name) FROM public.violations WHERE DATE(violation_time) = CURRENT_DATE - INTERVAL '1 day';
  ```
- **User question:** "List the violations from the last 7 days."
- **SQL command:**
  ```sql
  SELECT * FROM public.violations WHERE violation_time >= CURRENT_DATE - INTERVAL '7 days';
  ```

### Example: Aggregation Queries
- **User question:** "Count the number of violations by department, sorted from highest to lowest."
- **SQL command:**
  ```sql
  SELECT department, COUNT(id) AS violation_count FROM public.violations GROUP BY department ORDER BY violation_count DESC;
  ```
- **User question:** "Which department has the most unresolved violations?"
- **SQL command:**
  ```sql
  SELECT department, COUNT(id) AS violation_count FROM public.violations WHERE status = 'In Progress' GROUP BY department ORDER BY violation_count DESC LIMIT 1;
  ```

### Example: Synonym Handling Queries
- **User question:** "How many violations are related to not wearing a helmet?"
- **SQL command:**
  ```sql
  SELECT COUNT(id) FROM public.violations WHERE violation_type IN ('Not wearing helmet', 'Not using safety helmet', 'Missing helmet at construction site');
  ```
- **User question:** "List all instances of arriving late."
- **SQL command:**
  ```sql
  SELECT * FROM public.violations WHERE violation_type IN ('Arriving late', 'Coming to work late');
  ```

### Example: Queries with Multiple Conditions
- **User question:** "Find violations from the 'Production' department in 'Workshop A' that are still 'In Progress'."
- **SQL command:**
  ```sql
  SELECT * FROM public.violations WHERE department = 'Production' AND area = 'Workshop A' AND status = 'In Progress';
  ```

### Example: Sorting and Limiting Queries
- **User question:** "Show the 3 most recent employee violations."
- **SQL command:**
  ```sql
  SELECT employee_name, violation_type, violation_time FROM public.violations ORDER BY violation_time DESC LIMIT 3;
  ```

---

## Part 4: English Term Mapping & Temporal Phrases

### Common User Phrases → Canonical SQL Intent
- "in progress", "unresolved", "pending" → status = 'In Progress'
- "resolved", "closed", "completed" → status = 'Resolved'
- "number of violations", "violation count" → COUNT(*) or COUNT(id)
- "latest", "most recent", "recent" → ORDER BY violation_time DESC
- "how many" → COUNT(...)
- "list", "show all", "list all" → SELECT * (add filters if specified)
- "helmet violations" / "not wearing a helmet" → violation_type IN ('Not wearing helmet', 'Not using safety helmet', 'Missing helmet at construction site')
- "late arrivals" → violation_type IN ('Arriving late', 'Coming to work late')
- "area" → area column
- "department" → department column
- "top" / "highest" / "leaders" → ORDER BY <metric> DESC LIMIT n

### Temporal Phrase Normalization (English Only)
- "today" → DATE(violation_time) = CURRENT_DATE
- "yesterday" → DATE(violation_time) = CURRENT_DATE - INTERVAL '1 day'
- "last 7 days" → violation_time >= CURRENT_DATE - INTERVAL '7 days'
- "last 30 days" → violation_time >= CURRENT_DATE - INTERVAL '30 days'
- "this week" → DATE_TRUNC('week', violation_time) = DATE_TRUNC('week', CURRENT_DATE)
- "this month" → DATE_TRUNC('month', violation_time) = DATE_TRUNC('month', CURRENT_DATE)
- "this quarter" → DATE_TRUNC('quarter', violation_time) = DATE_TRUNC('quarter', CURRENT_DATE)
- "this year" → DATE_TRUNC('year', violation_time) = DATE_TRUNC('year', CURRENT_DATE)
- "recent" (ambiguous) → assume last 7 days unless specified otherwise

---

## Part 5: Reusable SQL Patterns

### 1. Count total violations
```sql
SELECT COUNT(*) AS total_violations FROM public.violations;
```

### 2. Count unresolved (In Progress) violations
```sql
SELECT COUNT(*) AS unresolved_violations FROM public.violations WHERE status = 'In Progress';
```

### 3. Count resolved violations in a period
```sql
SELECT COUNT(*) FROM public.violations 
WHERE status = 'Resolved' 
  AND violation_time >= CURRENT_DATE - INTERVAL '7 days';
```

### 4. Top frequent violators (by number of records)
```sql
SELECT employee_name, COUNT(*) AS violation_count
FROM public.violations
GROUP BY employee_name
ORDER BY violation_count DESC
LIMIT 5;
```

### 5. Latest violation per employee
```sql
SELECT DISTINCT ON (employee_name) employee_name, violation_type, violation_time, status
FROM public.violations
ORDER BY employee_name, violation_time DESC;
```

### 6. Violations by hour of day (for trend)
```sql
SELECT EXTRACT(HOUR FROM violation_time) AS hour, COUNT(*) AS count
FROM public.violations
GROUP BY hour
ORDER BY hour;
```

### 7. Daily violation counts last 14 days
```sql
SELECT DATE(violation_time) AS day, COUNT(*) AS count
FROM public.violations
WHERE violation_time >= CURRENT_DATE - INTERVAL '14 days'
GROUP BY day
ORDER BY day;
```

### 8. Distribution by violation_type (with percentage)
```sql
SELECT violation_type,
       COUNT(*) AS count,
       ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER (), 2) AS pct
FROM public.violations
GROUP BY violation_type
ORDER BY count DESC;
```

### 9. Unresolved violations older than 3 days
```sql
SELECT * FROM public.violations
WHERE status = 'In Progress'
  AND violation_time < NOW() - INTERVAL '3 days'
ORDER BY violation_time;
```

### 10. Employees with multiple unresolved violations
```sql
SELECT employee_name, COUNT(*) AS unresolved_count
FROM public.violations
WHERE status = 'In Progress'
GROUP BY employee_name
HAVING COUNT(*) > 1
ORDER BY unresolved_count DESC;
```

---

## Part 6: Disambiguation & Reasoning Guidance for LLM

1. If the user asks about "people" or "employees" in a counting context, consider distinct persons: use `COUNT(DISTINCT employee_name)`.
2. If the user asks "how many times" or "number of violations" count rows, not distinct employees.
3. Phrases like "unresolved", "pending", "still open" map to status = 'In Progress'.
4. For "total" requests, avoid adding filters unless the user specifies them.
5. Always restrict to the `violations` table; do not invent joins or extra columns.
6. If a synonym group (helmet / arriving late) appears, expand using the provided IN (...) pattern.
7. If timeframe wording is ambiguous (e.g., "recent"), default to last 7 days unless conversation history previously set a different window.
8. If both department and area are mentioned, include both conditions in WHERE.
9. If ordering intent appears ("top", "highest", "most"), use ORDER BY metric DESC and optionally LIMIT.
10. For percentage or proportion, compute percentage with a window function: `COUNT(*) * 100.0 / SUM(COUNT(*)) OVER ()`.

---

## Part 7: Follow-up Conversation Handling Hints

Use previous answers to resolve pronouns:
- "those", "these", "them", "those cases" → refer to the last result set. If a follow-up asks to further filter (e.g., "how many of those are unresolved?"), add an additional WHERE condition preserving the earlier scope.
- If a prior query produced a grouped aggregation and the user asks "who is first" / "who leads" / "top employee", reuse the grouping and ordering logic with `LIMIT 1`.

If context is insufficient to construct a precise SQL (e.g., pronoun with no prior list in history), respond with `no_answer`.

---

## Part 8: Example Multi-step Question → Refined SQL

Conversation:
User: "How many violations occurred this week?"
Assistant (reasoning): Count rows in current week → use DATE_TRUNC on violation_time.
Generated SQL:
```sql
SELECT COUNT(*) FROM public.violations
WHERE DATE_TRUNC('week', violation_time) = DATE_TRUNC('week', CURRENT_DATE);
```

Follow-up User: "How many of those have been resolved?"
Refined SQL (adds status filter, same week scope):
```sql
SELECT COUNT(*) FROM public.violations
WHERE DATE_TRUNC('week', violation_time) = DATE_TRUNC('week', CURRENT_DATE)
  AND status = 'Resolved';
```

---

## Part 9: Edge Cases & Safeguards

- If user requests columns that do not exist, respond with `no_answer`.
- Do not use wildcards for time like `violation_time LIKE '%2025%'`; always use date functions.
- Avoid `SELECT *` when user asks specifically for counts or aggregated metrics—return only needed columns.
- If user asks for a "percentage" or "proportion", include both absolute counts and computed percentage if grouping.
- Ensure LIMIT comes after ORDER BY.
- Always qualify ambiguous time phrases (like "recent") with a consistent assumption (default 7 days) unless overwritten in conversation.

---

## Part 10: Testing Prompts (LLM Internal Only)

Use these to self-check before final SQL:
- Are all columns referenced real? (id, employee_name, department, violation_type, area, violation_time, status)
- Are any synonyms expanded properly?
- Is timeframe implemented using correct PostgreSQL date functions?
- Is DISTINCT applied only when counting unique employees, not violations?
- Are ordering and limiting clauses coherent with the request?

If any check fails → output `no_answer`.

---

## Part 11: Sample Analytical Queries (Advanced)

### Monthly trend of unresolved vs resolved
```sql
SELECT DATE_TRUNC('month', violation_time) AS month,
       SUM(CASE WHEN status = 'In Progress' THEN 1 ELSE 0 END) AS unresolved,
       SUM(CASE WHEN status = 'Resolved' THEN 1 ELSE 0 END) AS resolved
FROM public.violations
GROUP BY month
ORDER BY month;
```

### Average violations per active day (days with at least one violation) last 30 days
```sql
WITH daily AS (
  SELECT DATE(violation_time) AS day, COUNT(*) AS c
  FROM public.violations
  WHERE violation_time >= CURRENT_DATE - INTERVAL '30 days'
  GROUP BY day
)
SELECT AVG(c)::numeric(10,2) AS avg_per_active_day FROM daily;
```

### Rolling 7-day window count (each day)
```sql
SELECT d::date AS day,
       (
         SELECT COUNT(*) FROM public.violations v2
         WHERE v2.violation_time >= d::date - INTERVAL '6 days'
           AND v2.violation_time < d::date + INTERVAL '1 day'
       ) AS last_7_day_count
FROM generate_series(CURRENT_DATE - INTERVAL '20 days', CURRENT_DATE, INTERVAL '1 day') AS g(d)
ORDER BY day;
```

### Peak violation hour (single row)
```sql
SELECT EXTRACT(HOUR FROM violation_time) AS hour, COUNT(*) AS count
FROM public.violations
GROUP BY hour
ORDER BY count DESC
LIMIT 1;
```

### Percentage of unresolved violations by department
```sql
SELECT department,
       COUNT(*) FILTER (WHERE status = 'In Progress') AS unresolved,
       COUNT(*) AS total,
       ROUND(100.0 * COUNT(*) FILTER (WHERE status = 'In Progress') / COUNT(*), 2) AS unresolved_pct
FROM public.violations
GROUP BY department
ORDER BY unresolved_pct DESC;
```

---

## Part 12: Maintenance Notes

- Update this knowledge base whenever new violation types or statuses are added.
- Re-run the embedding script after edits:
  1. Optional: Adjust splitter params in `embed_knowledge.py` if sections become too long.
  2. Run: `python embed_knowledge.py` (this recreates the PGVector table if `recreate_table=True`).
  3. Restart the Streamlit app so retriever uses the updated vectors.
- Keep synonym lists small and explicit for determinism.

